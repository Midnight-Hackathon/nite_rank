pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

export ledger registeredUsers: Map<Bytes<32>, Boolean>;  // User pubkey -> registered status
export ledger userProofs: Map<Bytes<32>, Counter>;  // User pubkey -> number of valid proofs submitted
export ledger totalVerified: Counter;  // Global tally (public for transparency)

// Witnesses fetch PRIVATE data from the user's local state
witness runDistance(): Uint<32>;  // User's private distance
witness runDuration(): Uint<32>;  // User's private duration

// Main circuit: User submits proof of run distance and duration
export circuit registerUser(userPk: Bytes<32>): [] {
  registeredUsers.insert(disclose(userPk), true);
  userProofs.insert(disclose(userPk), default<Counter>);
}

// Helper: Prove distance meets threshold
export circuit proveRunDistance(distance: Uint<32>, duration: Uint<32>): Boolean {
  const DistanceThreshold = 5000 as Uint<32>;  // 5km in meters
  const DurationThreshold = 1200 as Uint<32>;  // 20 minutes in seconds
  return distance >= DistanceThreshold && duration <= DurationThreshold;
}

// NEW: Circuit that CALLS the witnesses to get private data
export circuit submitRunProof(userPk: Bytes<32>): [] {
  // Fetch private values from witnesses (not disclosed on-chain!)
  const distance = runDistance();
  const duration = runDuration();

  const isRegistered = registeredUsers.lookup(disclose(userPk));
  assert(isRegistered, "User not registered");
  assert(proveRunDistance(distance, duration), "Run distance below 5km threshold");

  userProofs.lookup(disclose(userPk)).increment(1);
  totalVerified.increment(1);
}

// View function to get the number of proofs submitted by a user
export circuit getUserProofCount(userPk: Bytes<32>): Uint<64> {
  return userProofs.lookup(disclose(userPk)).read();
}